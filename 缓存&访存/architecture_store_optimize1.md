# architecture store optimize1


# Contents
- [1.缓存器中三种不命中情况](#heading-one)
- [2.基础优化一：增大 Cache Capacity 减少错失率](#heading-two)
- [3.基础优化二：增大块长度（Block Size）来减少错失率](#heading-two)
- [4.基础优化三：增加相关联性（Higher Associative）来减少错失率](#heading-two)

## 1.缓存器中三种不命中情况
----

* 必定发生的不命中（Compulsory Miss）
```
在系统刚刚启动，初始化缓存，即使一个无限容量的缓存，也必定会发生这种情况
```

* 由容量所限导致的不命中（Capacity Miss）
```
缓存其实是内存的映射，但缓存的大小几乎肯定远远小于内存的容量，所以因为容量有限导致的不命中
```

* 由冲突导致的不命中（Conflict Miss）
```
有些缓存被设计成两路相关联（Two-way Associ）或是四路相关联（Four-way Associ），在这些组（Sets）里经常会发生数据放满了，放不下其他相关的数据，这种因为组里的冲突而发生的不命中
```
``AMAT = Hit Time + Miss Rate * Miss Penalty``

优化上述公式中的三个指标，就可以大大减少咱们的内存访问时间，从而提高性能。而减少这三种不同种类的错失，也会减少整体的错失率（Miss Rate）

## 2.基础优化一：增大 Cache Capacity 减少错失率
----

缓存的总容量越大，也就意味着能放的数据越多，内存中的数据尽可能被多的映射进缓存。

缺点：增加了命中时的任务量：硬件需要再更多的数据中比较标签（Tag），命中时间（Hit Time）就会有所增加。

所以这是一个权衡（Trade-off），如果增大了总容量，错失率大大降低，但命中时间只增长一点，那么总体来说 AMAT 的值就会下降，达到优化的目的。
```如果缓存总容量提高一倍，那么错失率会降低sqrt(2)倍。```

## 3.基础优化二：增大块长度（Block Size）来减少错失率
----
1.块长度很小时，在缓存容量不变的情况下，块数量增加，导致一开始由于系统初始化必定发生的不命中（Compulsory Miss）增加。所以块长度很小时，错失率是很高的。

2.快长度逐渐增大，在缓存容量不变的情况下，错失率会有所降低，因为此时相比于之前，一次性从内存带上来的相连数据变多，很好的利用了空间局部性（Spatial Locality）。

3.块长度变得更大，在缓存容量和组的数量不变的情况下，每个组中的块数量变少，会导致由冲突导致的不命中（Conflict Miss）上升，进而导致总体错失率提高。不过有失必有得，此时附带了一个好处，那就是因为块变大，每个块存的数据变多，所需要的 位移（Offset） 位数增多，但地址的总体位数不能变，所以 标签（Tag） 所需要的位数就会下降（被 Offset 拿走了），所以硬件中的比较器（Comparator）会得到优化。

```块的长度选择应该结合俩点来确定：内存和缓存之间的带宽（Bandwidth） 和 延迟（Latency）```

1.带宽很大，延迟很大，适合长度更大的块，因为可以很好的利用其之间的带宽和总线（Bus）

2.带宽小，延迟小，适合长度小的块

## 4.基础优化三：增加相关联性（Higher Associative）来减少错失率

-----
在保持缓存总容量的情况下，增加相关联性，意味着组里的块个数增加，组的个数减少。这样一来，由冲突导致的不命中（Conflict Miss）会大大减少，这时，由容量导致的不命中（Capacity Miss）占据了 Miss 总个数的主导地位

不一直使用四路、八路、甚至全相关的缓存：

* 1 .全相联缓存对硬件要求很高，大大增加复杂度。

* 2 .组（Sets）的个数减少，所需要的 Index 位数变少，但 Tags 位数增加， 增加了缓存的命中时间（Hit Time）; 若增加太多，可能会成为电路中的关键路径（Critical Path）, 从而降低处理器的时钟周期时间（Cycle Time）

```
三大基础优化方法，从缓存容量、块长度、相关联性入手

```